Data Types:

Pt: My own subclass of Point2D.Double, Pt
  - Pt can hold custom data
  - Pt is a shorter name than "Point2D.Double"
  - Pt gives you methods that give you info about it's surroundings (though they just refer to the Functions static methods)
Vec: A math Vector object, with x and y components
  - Can scale/transform
  - Get angles, magnitude
  - Find arbitrary points in given directions from points, lines, etc
Line: A Line2D.Double
Sequence: A set of ordered points that forms a sketch stroke
  - Iterator to get at points
  - Iterator to get at lines
  - Sequence can be traverssed forward, backward
  - Sequence can wrap around on itself
  - Normalizing points (distributing them evenly)
IntersectionData: Special object giving more info re: intersection of two lines

Have                          Need                                      Method
----------------------------------------------------------------------------------------------------------------------
Point, Point                  Point exactly between the two                  D   Pt getPointBetween(Pt, Pt)
Point, Point                  Distance between the two                       D   double getDistanceBetween(Pt, Pt)
Point, Point                  Slope between two points (possibly infinite)   D   getSlope(Pt, Pt)
Point, Point		      Are they equal within some tolerance?	     D   eq(Pt, Pt, tolerance)
Points...		      Find the average point	 		     D	 getMean(Pt...)
Point, Point, double	      Rotate point A about pivot P by r radians	     D	 rotatePointAboutPivot(Pt, Pt, double)
Sequence, Point, double       Rotate seq. about pivot P by by r radians	     D	 rotatePointsAboutPivot(Sequence, Pt, double)
Point, Vector                 Point on other end of Vector                   D   Pt getEndPoint(Pt, Vec)
Point, Vector                 Get Line passing thru point in direction       D   Pt getLineFromPoint(Pt, Vec)
Point, Line                   Distance between Point and Line                D   double getDistanceBetweenPointAndLine(Pt, Line)
Point, Line                   Point on line that is closest                  D   Pt getNearestPointOnLine(Pt, Line)
int			      See if p is left(-1)/on(0)/right(1) of a Line  D	 int getPartition(Pt, Line)
Point, Point, Point           Center of a circle                             D   Pt getCircleCenter(Pt, Pt, Pt)
Point, Point, Point           Curvature of a line at some point              D   Pt getCurvature(Pt, Pt, Pt)
Vector                        Normal                                         D   Vec getVectorNormal(Vec, int)
Vector, double                Get a vector scaled by amt                     D   Vec getScaledVector(Vec, double)
Vector, double                Get a vector of the given desired magnitude    D   Vec getVectorOfMagnitude(Vec, double)
Vector                        Get negative (flip) Vector                     D   Vec getVectorFlip(Vec)
Vector, Vector                Angle between the two                          D   double getAngleBetween(Vec, Vec)
Vector, Vector                Get dot product                                D   double getDotProduct(Vec, Vec)
Vector, Vector                Get cross product                              D   Vec getCrossProduct(Vec, Vec)
Vector, Vector                Get determinant                                D   double getDeterminant(Vec, Vec)
Vector, Vector                Get vector separating input                    D   getSpanningVector(Vec, Vec)
Vector                        Get magnitude (length)                         D   getVectorMagnitude(Vec)
Line                          Get midpoint                                   D   getLineMidpoint(Line)
Line                          Get length                                     D   getLineLength(Line)
Line                          Get vector                                     D   getLineVector(Line)
Line, Line                    Get intersection data                          D   getIntersectionData(Line, Line)
Line, Line                    Intersection point                             D   getIntersectionPoint(Line, Line)
Line, Line                    Get distance between two lines                 D   getMinDistBetweenLines(Line, Line)
Sequence, double	      Get a normalized sequence			     D   getNormalizedSequence(Sequence, double)
Sequence, Point               Get distance from point to seq.                D   getMinDistBetweenPointAndSequence(Pt, Sequence)
Sequence, Point               Get nearest point to seq.                      D   getNearestPointOnSequence(Pt, Sequence)
Sequence, double              Evenly distribute points given amt             T   Sequence.normalize(double)
Sequence, Sequence            Lash the two sequences together                T
Sequence, Point, Point        Get min dist between points on seq             D   getMinDistBetweenPointsOnSequence(Sequence, Pt, Pt)
Sequence, Point               Blot select near given point                   T
Sequence                      Clear blot selection                           T
Sequence                      Select all                                     T
Sequence, Point, Point        Establish a region on the sequence             DT
Sequence, Sequence            Generate Tween sequence to another             D   getTweenBetweenSequences(Sequence, Sequence)
Sequence, Sequence            Replace portion of one sequence with another   T
Sequence                      Get informative data about shape of sequence   DT  getInfoPoints(Sequence)
Sequence                      Get bounding box                               D   getSequenceBoundingBox(Sequence)
Sequence                      Get convex hull                                D   getConvexHull(Sequence)
Sequence                      Get first derivative                           D   getDerivative(Sequence)
Sequence, Line                Get minimum distance from line to sequence     D   getMinDistBetweenLineAndSequence(Line, Sequence)
Sequence, Line                Get intersection(s) of sequence and line       D   getIntersectionsOfLineAndSequence(Line, Sequence)
Sequence, double              Scale the sequence by given amount             T   
Sequence, Vector              Move selected points according to given vector T
Point, Point, Point, Point    Get a sequence of points for a spline patch    D   getSplinePatch(Point, Point, Point, Point)
Sequence, int                 Get a spline (sequence) with # of ctrl points  D   getSpline(Sequence, int)
Sequence, int, dbl, int, dbl  Get intrpl. Point on seq at fraction distance  D   getPointAtFractionalDistance(Sequence, int, dbl, int, dbl)
Rectangle, Rectangle          Get an affine transformation mapping a to b    T   getAffineTransform(Rectangle, Rectangle)
Rectangle, Rectangle	      Get Hausdorff distance between rectangles	     D	 getHausdorffDistance(Rectangle, Rectangle)
Rectangle, Pt		      Get distance from a point to rectangle center  D	 getDistanceToCenter(Rectangle, Pt)
Rectangle              	      Get Rectangle center                           D   getRectangleCenter(Rectangle)
Rectangle		      Get Rectangle area			     D	 getRectangleArea(Rectangle)
double, double, double 	      Get a percentage given three values	     D	 getFraction(double, double, double)
Point, Line		      Get fast intsect of horiz ray right from Pt    D	 getWindingIntersect(Pt, Line) (rets boolean)
Point, List<Sequence>	      Gives crossing count for horiz ray to lines    D	 getCrossingNumber(Pt, List<Sequence>)
Point, Sequence		      Gives crossing count for horiz ray to lines    D	 getCrossingNumber(Pt, Sequence)
double...		      Gives you the sum of some list of numbers	     D	 getSum(double...)

The following functions are available using the Statistics class.

Have                          Need                                      Method
----------------------------------------------------------------------------------------------------------------------
double[]                      Get mean value       	   	             D   getMean(double[])
double[]                      Get variance                                   D   getVariance(double[])
double[]                      Get standard deviation                         D   getStandardDeviation(double[])

GUI components for testing

SketchPad component must:
 - Allow points to be added to sequences
 - Allow 'informative points' to be added
 - Allow for 2D mean 'informative points' be applied
 - Draw sequences and 'informative points'

Graph component must:
 - Allow points to be added to sequences
 - Allow 'intersting points' to be added
 - Name of graph
 - axis names
 - Draw sequences and 'informative points' and name of graph and axes

Both of these things seem to have similar functionality, including:

 - Allow points to be added to sequences
 - Allow 'informative points' to be added
 - Draw sequences and 'informative points'

The only difference is the graph also shows axes and labels. So Graph
should probably simply be a subclass of SketchPad.

The mouse input is handled by a MouseHandler, which is both a motion
and click listener. SketchPads can be closed off to user input so that
it doesn't accept points as the result of a click or drag, but that
must be separated from tooltip motion events. 

---------------

Due to a bug in Java2D, I need to write my own graphics transformation
and drawing class. From my last svn commit log:

    Consider the following code:

    g.scale(0.5, 0.5);
    g.draw(myShape);

    You would think that myShape's getPathIterator(AffineTransform
    affine) method would be called with a non-null argument that
    explains the transformation to the shape so it can report it's
    points in the correct coordinates. But, that's not what happens at
    all. I don't know how to work around it, so I am going to build a
    new graphics transformation component that maybe will make life
    easier for doing drawings.

The new drawing/transformation object will be called "Pablo", after
the painter Pablo Picasso. He was known for contorting his subjects
into strange shears, elongations, and putting things in 'wrong' spots.

Here is how an object might use a Pablo instance:

public void paintComponent(Graphics g) {
  Bounds myBounds = makeBounds(getSize()); // this component's drawing bounds
  Bounds idealBounds = makeBounds(data); // bounds of the ideal coordinates
  Pablo pablo = new Pablo(g, myBounds, idealBounds); // defines an affine transform
  pablo.usePen(new Pen(Color.red, 1.2));
  pablo.drawAxes();
  pablo.usePen(new Pen(Color.black, 1.0));
  for (Shape s : myShapes) {
    pablo.draw(s); // uses s.getPathIterator using CORRECT affine transform
  }
  pablo.drawText("Hello", .4, .4); // draws Hello at ideal coordinates .4, .4 using 
                                // non-transformed glyph sizes so you can read them.
}

Obviously for efficiency reasons the object initialization would
happen elsewhere so it doesn't take place every time, but you get the
point.
